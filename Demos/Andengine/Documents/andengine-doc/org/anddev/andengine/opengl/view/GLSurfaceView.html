<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_23) on Tue Jul 26 00:14:52 CEST 2011 -->
<TITLE>
GLSurfaceView
</TITLE>

<META NAME="date" CONTENT="2011-07-26">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GLSurfaceView";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GLSurfaceView.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/anddev/andengine/opengl/view/GLSurfaceView.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GLSurfaceView.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.anddev.andengine.opengl.view</FONT>
<BR>
Class GLSurfaceView</H2>
<PRE>
<A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by ">SurfaceView
      <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>org.anddev.andengine.opengl.view.GLSurfaceView</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../../org/anddev/andengine/opengl/view/RenderSurfaceView.html" title="class in org.anddev.andengine.opengl.view">RenderSurfaceView</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>GLSurfaceView</B><DT>extends SurfaceView</DL>
</PRE>

<P>
An implementation of SurfaceView that uses the dedicated surface for displaying OpenGL rendering.
 <p>
 A GLSurfaceView provides the following features:
 <p>
 <ul>
 <li>Manages a surface, which is a special piece of memory that can be composited into the Android
 view system.
 <li>Manages an EGL display, which enables OpenGL to render into a surface.
 <li>Accepts a user-provided Renderer object that does the actual rendering.
 <li>Renders on a dedicated thread to decouple rendering performance from the UI thread.
 <li>Supports both on-demand and continuous rendering.
 <li>Optionally wraps, traces, and/or error-checks the renderer'MAGIC_CONSTANT OpenGL calls.
 </ul>
 <h3>Using GLSurfaceView</h3>
 <p>
 Typically you use GLSurfaceView by subclassing it and overriding one or more of the View system
 input event methods. If your application does not need to override event methods then
 GLSurfaceView can be used as-is. For the most part GLSurfaceView behavior is customized by
 calling "set" methods rather than by subclassing. For example, unlike a regular View, drawing is
 delegated to a separate Renderer object which is registered with the GLSurfaceView using the
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> call.
 <p>
 <h3>Initializing GLSurfaceView</h3> All you have to do to initialize a GLSurfaceView is call
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A>. However, if desired, you can modify the default behavior of
 GLSurfaceView by calling one or more of these methods before calling setRenderer:
 <ul>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(boolean)"><CODE>setEGLConfigChooser(boolean)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)"><CODE>setEGLConfigChooser(EGLConfigChooser)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(int, int, int, int, int, int)"><CODE>setEGLConfigChooser(int, int, int, int, int, int)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)"><CODE>setGLWrapper(GLWrapper)</CODE></A>
 </ul>
 <p>
 <h4>Choosing an EGL Configuration</h4> A given Android device may support multiple possible types
 of drawing surfaces. The available surfaces may differ in how may channels of data are present,
 as well as how many bits are allocated to each channel. Therefore, the first thing GLSurfaceView
 has to do when starting to render is choose what type of surface to use.
 <p>
 By default GLSurfaceView chooses an available surface that'MAGIC_CONSTANT closest to a 16-bit
 R5G6B5 surface with a 16-bit depth buffer and no stencil. If you would prefer a different surface
 (for example, if you do not need a depth buffer) you can override the default behavior by calling
 one of the setEGLConfigChooser methods.
 <p>
 <h4>Debug Behavior</h4> You can optionally modify the behavior of GLSurfaceView by calling one or
 more of the debugging methods <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>, and <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)"><CODE>setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)</CODE></A>. These
 methods may be called before and/or after setRenderer, but typically they are called before
 setRenderer so that they take effect immediately.
 <p>
 <h4>Setting a Renderer</h4> Finally, you must call <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)</CODE></A> to register a
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view"><CODE>GLSurfaceView.Renderer</CODE></A>. The renderer is responsible for doing the actual OpenGL rendering.
 <p>
 <h3>Rendering Mode</h3> Once the renderer is set, you can control whether the renderer draws
 continuously or on-demand by calling <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>. The default is continuous rendering.
 <p>
 <h3>Activity Life-cycle</h3> A GLSurfaceView must be notified when the activity is paused and
 resumed. GLSurfaceView clients are required to call <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onPause()"><CODE>onPause()</CODE></A> when the activity pauses
 and <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onResume()"><CODE>onResume()</CODE></A> when the activity resumes. These calls allow GLSurfaceView to pause and
 resume the rendering thread, and also allow GLSurfaceView to release and recreate the OpenGL
 display.
 <p>
 <h3>Handling events</h3>
 <p>
 To handle an event you will typically subclass GLSurfaceView and override the appropriate method,
 just as you would with any other View. However, when handling the event, you may need to
 communicate with the Renderer object that'MAGIC_CONSTANT running in the rendering thread. You can
 do this using any standard Java cross-thread communication mechanism. In addition, one relatively
 easy way to communicate with your renderer is to call <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#queueEvent(java.lang.Runnable)"><CODE>queueEvent(Runnable)</CODE></A>. For example:
 
 <pre class="prettyprint">
 class MyGLSurfaceView extends GLSurfaceView {
 
        private MyRenderer mMyRenderer;
 
        public void start() {
         mMyRenderer = ...;
         setRenderer(mMyRenderer);
     }
 
        public boolean onKeyDown(int keyCode, KeyEvent event) {
                if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
                        queueEvent(new Runnable() {
                                // This method will be called on the rendering
                                // thread:
                                public void run() {
                                        mMyRenderer.handleDpadCenter();
                                }
                        });
                        return true;
                }
                return super.onKeyDown(keyCode, event);
        }
 }
 </pre>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A generic renderer interface.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_CHECK_GL_ERROR">DEBUG_CHECK_GL_ERROR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check glError() after every GL call and throw an exception if glError indicates that an error
 has occurred.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_LOG_GL_CALLS">DEBUG_LOG_GL_CALLS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_CONTINUOUSLY">RENDERMODE_CONTINUOUSLY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The renderer is called continuously to re-render the scene.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY">RENDERMODE_WHEN_DIRTY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The renderer only renders when the surface is created, or when <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A> is
 called.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#GLSurfaceView(Context)">GLSurfaceView</A></B>(Context&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Standard View constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#GLSurfaceView(Context, AttributeSet)">GLSurfaceView</A></B>(Context&nbsp;context,
              AttributeSet&nbsp;attrs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Standard View constructor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getDebugFlags()">getDebugFlags</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current value of the debug flags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()">getRenderMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current rendering mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onPause()">onPause</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inform the view that the activity is paused.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onResume()">onResume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inform the view that the activity is resumed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#queueEvent(java.lang.Runnable)">queueEvent</A></B>(<A HREF="http://developer.android.com/reference/java/lang/Runnable.html?is-external=true" title="class or interface in java.lang">Runnable</A>&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue a runnable to be run on the GL rendering thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()">requestRender</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Request that the renderer render a frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)">setDebugFlags</A></B>(int&nbsp;debugFlags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the debug flags to a new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(boolean)">setEGLConfigChooser</A></B>(boolean&nbsp;needDepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install a config chooser which will choose a config as close to 16-bit RGB as possible, with
 or without an optional depth buffer as close to 16-bits as possible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)">setEGLConfigChooser</A></B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view">EGLConfigChooser</A>&nbsp;configChooser)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install a custom EGLConfigChooser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(int, int, int, int, int, int)">setEGLConfigChooser</A></B>(int&nbsp;redSize,
                    int&nbsp;greenSize,
                    int&nbsp;blueSize,
                    int&nbsp;alphaSize,
                    int&nbsp;depthSize,
                    int&nbsp;stencilSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install a config chooser which will choose a config with at least the specified component
 sizes, and as close to the specified component sizes as possible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)">setGLWrapper</A></B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html" title="interface in org.anddev.andengine.opengl.view">GLWrapper</A>&nbsp;glWrapper)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the glWrapper.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)">setRenderer</A></B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A>&nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the renderer associated with this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)">setRenderMode</A></B>(int&nbsp;renderMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the rendering mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#surfaceChanged(SurfaceHolder, int, int, int)">surfaceChanged</A></B>(SurfaceHolder&nbsp;holder,
               int&nbsp;format,
               int&nbsp;w,
               int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is part of the SurfaceHolder.Callback interface, and is not normally called or
 subclassed by clients of GLSurfaceView.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#surfaceCreated(SurfaceHolder)">surfaceCreated</A></B>(SurfaceHolder&nbsp;holder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is part of the SurfaceHolder.Callback interface, and is not normally called or
 subclassed by clients of GLSurfaceView.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#surfaceDestroyed(SurfaceHolder)">surfaceDestroyed</A></B>(SurfaceHolder&nbsp;holder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is part of the SurfaceHolder.Callback interface, and is not normally called or
 subclassed by clients of GLSurfaceView.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://developer.android.com/reference/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="RENDERMODE_WHEN_DIRTY"><!-- --></A><H3>
RENDERMODE_WHEN_DIRTY</H3>
<PRE>
public static final int <B>RENDERMODE_WHEN_DIRTY</B></PRE>
<DL>
<DD>The renderer only renders when the surface is created, or when <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A> is
 called.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()"><CODE>getRenderMode()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.RENDERMODE_WHEN_DIRTY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RENDERMODE_CONTINUOUSLY"><!-- --></A><H3>
RENDERMODE_CONTINUOUSLY</H3>
<PRE>
public static final int <B>RENDERMODE_CONTINUOUSLY</B></PRE>
<DL>
<DD>The renderer is called continuously to re-render the scene.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()"><CODE>getRenderMode()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.RENDERMODE_CONTINUOUSLY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DEBUG_CHECK_GL_ERROR"><!-- --></A><H3>
DEBUG_CHECK_GL_ERROR</H3>
<PRE>
public static final int <B>DEBUG_CHECK_GL_ERROR</B></PRE>
<DL>
<DD>Check glError() after every GL call and throw an exception if glError indicates that an error
 has occurred. This can be used to help track down which OpenGL ES call is causing an error.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getDebugFlags()"><CODE>getDebugFlags()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.DEBUG_CHECK_GL_ERROR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DEBUG_LOG_GL_CALLS"><!-- --></A><H3>
DEBUG_LOG_GL_CALLS</H3>
<PRE>
public static final int <B>DEBUG_LOG_GL_CALLS</B></PRE>
<DL>
<DD>Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getDebugFlags()"><CODE>getDebugFlags()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.DEBUG_LOG_GL_CALLS">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GLSurfaceView(Context)"><!-- --></A><H3>
GLSurfaceView</H3>
<PRE>
public <B>GLSurfaceView</B>(Context&nbsp;context)</PRE>
<DL>
<DD>Standard View constructor. In order to render something, you must call <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)</CODE></A>
 to register a renderer.
<P>
</DL>
<HR>

<A NAME="GLSurfaceView(Context, AttributeSet)"><!-- --></A><H3>
GLSurfaceView</H3>
<PRE>
public <B>GLSurfaceView</B>(Context&nbsp;context,
                     AttributeSet&nbsp;attrs)</PRE>
<DL>
<DD>Standard View constructor. In order to render something, you must call <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)</CODE></A>
 to register a renderer.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)"><!-- --></A><H3>
setGLWrapper</H3>
<PRE>
public void <B>setGLWrapper</B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html" title="interface in org.anddev.andengine.opengl.view">GLWrapper</A>&nbsp;glWrapper)</PRE>
<DL>
<DD>Set the glWrapper. If the glWrapper is not null, its <A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html#wrap(GL)"><CODE>GLWrapper.wrap(GL)</CODE></A> method is
 called whenever a surface is created. A GLWrapper can be used to wrap the GL object
 that'MAGIC_CONSTANT passed to the renderer. Wrapping a GL object enables examining and
 modifying the behavior of the GL calls made by the renderer.
 <p>
 Wrapping is typically used for debugging purposes.
 <p>
 The default value is null.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>glWrapper</CODE> - the new GLWrapper</DL>
</DD>
</DL>
<HR>

<A NAME="setDebugFlags(int)"><!-- --></A><H3>
setDebugFlags</H3>
<PRE>
public void <B>setDebugFlags</B>(int&nbsp;debugFlags)</PRE>
<DL>
<DD>Set the debug flags to a new value. The value is constructed by OR-together zero or more of
 the DEBUG_CHECK_* constants. The debug flags take effect whenever a surface is created. The
 default value is zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>debugFlags</CODE> - the new debug flags<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_CHECK_GL_ERROR"><CODE>DEBUG_CHECK_GL_ERROR</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_LOG_GL_CALLS"><CODE>DEBUG_LOG_GL_CALLS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDebugFlags()"><!-- --></A><H3>
getDebugFlags</H3>
<PRE>
public int <B>getDebugFlags</B>()</PRE>
<DL>
<DD>Get the current value of the debug flags.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current value of the debug flags.</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><!-- --></A><H3>
setRenderer</H3>
<PRE>
public void <B>setRenderer</B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A>&nbsp;renderer)</PRE>
<DL>
<DD>Set the renderer associated with this view. Also starts the thread that will call the
 renderer, which in turn causes the rendering to start.
 <p>
 This method should be called once and only once in the life-cycle of a GLSurfaceView.
 <p>
 The following GLSurfaceView methods can only be called <em>before</em> setRenderer is called:
 <ul>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(boolean)"><CODE>setEGLConfigChooser(boolean)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)"><CODE>setEGLConfigChooser(EGLConfigChooser)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(int, int, int, int, int, int)"><CODE>setEGLConfigChooser(int, int, int, int, int, int)</CODE></A>
 </ul>
 <p>
 The following GLSurfaceView methods can only be called <em>after</em> setRenderer is called:
 <ul>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()"><CODE>getRenderMode()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onPause()"><CODE>onPause()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onResume()"><CODE>onResume()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#queueEvent(java.lang.Runnable)"><CODE>queueEvent(Runnable)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderer</CODE> - the renderer to use to perform OpenGL drawing.</DL>
</DD>
</DL>
<HR>

<A NAME="setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)"><!-- --></A><H3>
setEGLConfigChooser</H3>
<PRE>
public void <B>setEGLConfigChooser</B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view">EGLConfigChooser</A>&nbsp;configChooser)</PRE>
<DL>
<DD>Install a custom EGLConfigChooser.
 <p>
 If this method is called, it must be called before <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> is called.
 <p>
 If no setEGLConfigChooser method is called, then by default the view will choose a config as
 close to 16-bit RGB as possible, with a depth buffer as close to 16 bits as possible.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>configChooser</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="setEGLConfigChooser(boolean)"><!-- --></A><H3>
setEGLConfigChooser</H3>
<PRE>
public void <B>setEGLConfigChooser</B>(boolean&nbsp;needDepth)</PRE>
<DL>
<DD>Install a config chooser which will choose a config as close to 16-bit RGB as possible, with
 or without an optional depth buffer as close to 16-bits as possible.
 <p>
 If this method is called, it must be called before <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> is called.
 <p>
 If no setEGLConfigChooser method is called, then by default the view will choose a config as
 close to 16-bit RGB as possible, with a depth buffer as close to 16 bits as possible.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>needDepth</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="setEGLConfigChooser(int, int, int, int, int, int)"><!-- --></A><H3>
setEGLConfigChooser</H3>
<PRE>
public void <B>setEGLConfigChooser</B>(int&nbsp;redSize,
                                int&nbsp;greenSize,
                                int&nbsp;blueSize,
                                int&nbsp;alphaSize,
                                int&nbsp;depthSize,
                                int&nbsp;stencilSize)</PRE>
<DL>
<DD>Install a config chooser which will choose a config with at least the specified component
 sizes, and as close to the specified component sizes as possible.
 <p>
 If this method is called, it must be called before <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> is called.
 <p>
 If no setEGLConfigChooser method is called, then by default the view will choose a config as
 close to 16-bit RGB as possible, with a depth buffer as close to 16 bits as possible.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderMode(int)"><!-- --></A><H3>
setRenderMode</H3>
<PRE>
public void <B>setRenderMode</B>(int&nbsp;renderMode)</PRE>
<DL>
<DD>Set the rendering mode. When renderMode is RENDERMODE_CONTINUOUSLY, the renderer is called
 repeatedly to re-render the scene. When renderMode is RENDERMODE_WHEN_DIRTY, the renderer
 only rendered when the surface is created, or when <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A> is called. Defaults
 to RENDERMODE_CONTINUOUSLY.
 <p>
 Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance by
 allowing the GPU and CPU to idle when the view does not need to be updated.
 <p>
 This method can only be called after <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderMode</CODE> - one of the RENDERMODE_X constants<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_CONTINUOUSLY"><CODE>RENDERMODE_CONTINUOUSLY</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY"><CODE>RENDERMODE_WHEN_DIRTY</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRenderMode()"><!-- --></A><H3>
getRenderMode</H3>
<PRE>
public int <B>getRenderMode</B>()</PRE>
<DL>
<DD>Get the current rendering mode. May be called from any thread. Must not be called before a
 renderer has been set.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current rendering mode.<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_CONTINUOUSLY"><CODE>RENDERMODE_CONTINUOUSLY</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY"><CODE>RENDERMODE_WHEN_DIRTY</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestRender()"><!-- --></A><H3>
requestRender</H3>
<PRE>
public void <B>requestRender</B>()</PRE>
<DL>
<DD>Request that the renderer render a frame. This method is typically used when the render mode
 has been set to <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY"><CODE>RENDERMODE_WHEN_DIRTY</CODE></A>, so that frames are only rendered on demand.
 May be called from any thread. Must be called after onResume() and before onPause().
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="surfaceCreated(SurfaceHolder)"><!-- --></A><H3>
surfaceCreated</H3>
<PRE>
public void <B>surfaceCreated</B>(SurfaceHolder&nbsp;holder)</PRE>
<DL>
<DD>This method is part of the SurfaceHolder.Callback interface, and is not normally called or
 subclassed by clients of GLSurfaceView.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="surfaceDestroyed(SurfaceHolder)"><!-- --></A><H3>
surfaceDestroyed</H3>
<PRE>
public void <B>surfaceDestroyed</B>(SurfaceHolder&nbsp;holder)</PRE>
<DL>
<DD>This method is part of the SurfaceHolder.Callback interface, and is not normally called or
 subclassed by clients of GLSurfaceView.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="surfaceChanged(SurfaceHolder, int, int, int)"><!-- --></A><H3>
surfaceChanged</H3>
<PRE>
public void <B>surfaceChanged</B>(SurfaceHolder&nbsp;holder,
                           int&nbsp;format,
                           int&nbsp;w,
                           int&nbsp;h)</PRE>
<DL>
<DD>This method is part of the SurfaceHolder.Callback interface, and is not normally called or
 subclassed by clients of GLSurfaceView.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="onPause()"><!-- --></A><H3>
onPause</H3>
<PRE>
public void <B>onPause</B>()</PRE>
<DL>
<DD>Inform the view that the activity is paused. The owner of this view must call this method
 when the activity is paused. Calling this method will pause the rendering thread. Must not be
 called before a renderer has been set.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="onResume()"><!-- --></A><H3>
onResume</H3>
<PRE>
public void <B>onResume</B>()</PRE>
<DL>
<DD>Inform the view that the activity is resumed. The owner of this view must call this method
 when the activity is resumed. Calling this method will recreate the OpenGL display and resume
 the rendering thread. Must not be called before a renderer has been set.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="queueEvent(java.lang.Runnable)"><!-- --></A><H3>
queueEvent</H3>
<PRE>
public void <B>queueEvent</B>(<A HREF="http://developer.android.com/reference/java/lang/Runnable.html?is-external=true" title="class or interface in java.lang">Runnable</A>&nbsp;r)</PRE>
<DL>
<DD>Queue a runnable to be run on the GL rendering thread. This can be used to communicate with
 the Renderer on the rendering thread. Must be called after onResume() and before onPause().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - the runnable to be run on the GL rendering thread.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GLSurfaceView.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/anddev/andengine/opengl/view/GLSurfaceView.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GLSurfaceView.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
